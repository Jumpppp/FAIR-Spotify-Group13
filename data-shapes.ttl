@prefix sh:      <http://www.w3.org/ns/shacl#> .
@prefix xsd:     <http://www.w3.org/2001/XMLSchema#> .
@prefix schema:  <https://schema.org/> .
@prefix skos:    <http://www.w3.org/2004/02/skos/core#> .
@prefix ex:      <https://w3id.org/jump/spotify/prop/> .

################################################################
# Track shape â€” validate instances of schema:MusicRecording
################################################################
ex:TrackShape
  a sh:NodeShape ;
  sh:targetClass schema:MusicRecording ;
  sh:nodeKind sh:IRI ;

  ######### IDENTIFICATION / DESCRIPTIVE #########

  # schema:url should be an IRI
  sh:property [
    sh:path schema:url ;
    sh:nodeKind sh:IRI ;
  ] ;

  # name is required string
  sh:property [
    sh:path schema:name ;
    sh:minCount 1 ;
    sh:datatype xsd:string ;
  ] ;

  # datePublished can be date OR dateTime (accept both)
  sh:property [
    sh:path schema:datePublished ;
    sh:or (
      [ sh:datatype xsd:date ]
      [ sh:datatype xsd:dateTime ]
    )
  ] ;

  ######### LINKS (allow current strings OR future IRIs) #########

  # byArtist: accept Person or MusicGroup IRIs OR a literal name (your table)
  sh:property [
    sh:path schema:byArtist ;
    sh:minCount 1 ;
    sh:or (
      [ sh:nodeKind sh:IRI ; sh:class schema:Person ]
      [ sh:nodeKind sh:IRI ; sh:class schema:MusicGroup ]
      [ sh:datatype xsd:string ]      # current CSV->RDF literal names
    )
  ] ;

  # inAlbum: accept Album IRI OR literal title (your table)
  sh:property [
    sh:path schema:inAlbum ;
    sh:or (
      [ sh:nodeKind sh:IRI ; sh:class schema:MusicAlbum ]
      [ sh:datatype xsd:string ]
    )
  ] ;

  # isPartOf (playlist): IRI to MusicPlaylist OR literal name
  sh:property [
    sh:path schema:isPartOf ;
    sh:or (
      [ sh:nodeKind sh:IRI ; sh:class schema:MusicPlaylist ]
      [ sh:datatype xsd:string ]
    )
  ] ;

  # genre: use SKOS Concept IRIs OR literal labels (since you dropped MO)
  sh:property [
    sh:path schema:genre ;
    sh:minCount 1 ;
    sh:or (
      [ sh:nodeKind sh:IRI ; sh:class skos:Concept ]
      [ sh:datatype xsd:string ]
    )
  ] ;

  # optional subgenre as a literal (since no MO); if you model SKOS later,
  # move this to a concept with skos:broader and validate that instead.
  sh:property [
    sh:path ex:subGenre ;         # <-- use this predicate in your RDF if needed
    sh:datatype xsd:string ;
    sh:maxCount 1
  ] ;

  ######### NUMERIC CONSTRAINTS (your feature columns) #########

  # durationMs: [0, 1,000,000]
  sh:property [
    sh:path ex:durationMs ;
    sh:datatype xsd:double ;
    sh:minInclusive 0 ;
    sh:maxInclusive 1000000 ;
  ] ;

  # trackPopularity: [0, 100]
  sh:property [
    sh:path ex:trackPopularity ;
    sh:datatype xsd:double ;
    sh:minInclusive 0 ;
    sh:maxInclusive 100 ;
  ] ;

  # tempo: [0, 250]
  sh:property [
    sh:path ex:tempo ;
    sh:datatype xsd:double ;
    sh:minInclusive 0 ;
    sh:maxInclusive 250 ;
  ] ;

  # key: [-1, 11]
  sh:property [
    sh:path ex:key ;
    sh:datatype xsd:int ;
    sh:minInclusive -1 ;
    sh:maxInclusive 11 ;
  ] ;

  # mode: {0,1}
  sh:property [
    sh:path ex:mode ;
    sh:datatype xsd:int ;
    sh:in ( 0 1 ) ;
  ] ;

  # timeSignature: >= 1
  sh:property [
    sh:path ex:timeSignature ;
    sh:datatype xsd:int ;
    sh:minInclusive 1 ;
  ] ;

  # loudness: [-60, 0]
  sh:property [
    sh:path ex:loudness ;
    sh:datatype xsd:double ;
    sh:minInclusive -60 ;
    sh:maxInclusive 0 ;
  ] ;

  # energy/danceability/liveness/valence/speechiness/instrumentalness/acousticness: [0,1]
  sh:property [ sh:path ex:energy ;            sh:datatype xsd:double ; sh:minInclusive 0 ; sh:maxInclusive 1 ] ;
  sh:property [ sh:path ex:danceability ;      sh:datatype xsd:double ; sh:minInclusive 0 ; sh:maxInclusive 1 ] ;
  sh:property [ sh:path ex:liveness ;          sh:datatype xsd:double ; sh:minInclusive 0 ; sh:maxInclusive 1 ] ;
  sh:property [ sh:path ex:valence ;           sh:datatype xsd:double ; sh:minInclusive 0 ; sh:maxInclusive 1 ] ;
  sh:property [ sh:path ex:speechiness ;       sh:datatype xsd:double ; sh:minInclusive 0 ; sh:maxInclusive 1 ] ;
  sh:property [ sh:path ex:instrumentalness ;  sh:datatype xsd:double ; sh:minInclusive 0 ; sh:maxInclusive 1 ] ;
  sh:property [ sh:path ex:acousticness ;      sh:datatype xsd:double ; sh:minInclusive 0 ; sh:maxInclusive 1 ] .
